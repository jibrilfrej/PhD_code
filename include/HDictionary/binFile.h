/**
 \file binFile.h
 \brief Format de l'entete des fichiers binaires
 \author Jean-Pierre Chevallet (Jean-Pierre.Chevallet@imag.fr)
 \copyright Laboratoire d'Informatique de Grenoble.
 \copyright Université de Grenoble (Pierre Mendès France UPMF).
 \copyright Centre National de la Recherche Scienfifique (CNRS).
 \date 2012
 \note IOTA Information Retrieval System
 \ingroup System
 */

#ifndef binFile_h
#define binFile_h

#include <stdio.h>
#include <time.h>


#include <string>
using std::string;

#include "error.h"
using IOTA::Error;

#include "system.h"
using SYSTEM::U16;
using SYSTEM::U64;
using SYSTEM::U32;


#include "tools.h"
using IOTA::chomp;

//#include "version.h"

namespace IOTA {
    
    /// Liste des formats reconnus
    enum FileFormat {
        fIOTA,  ///< Format binaire IOTA
        fKOEN,  ///< Fichier de sortie des outils de KOEN
        fXML,   ///< Fichier XML
        fOTHER, ///< Autre fichier (non détaillé)
        fEMPTY, ///< Fichier vide (format inconnu)
        fERROR  ///< Impossible d'accéder au fichier (format inconnu)
    };
    
    
    // JPC RIEN NE DOIT ETRE SPECIFIQUE ICI : a enlever
    const char* headerOriginal = "codebook_O";
    const char* headerHierarchical = "codebook_H";
    
    // JPC RIEN NE DOIT ETRE SPECIFIQUE ICI : a enlever
    enum eCodebookType {
        cOriginal,   ///<codebook generated by the original kmeans
        cHierarchical, ///< codebook generated by the hierachical kmeans
    };
    
    // Constante Identification de fichier
    const char FID[] = "IOTA";
    const size_t sizeFID = 4;
    
    // Constante Endianess DC2/DC4
    const U16 endianness = 0x1214;
    const time_t t0 = 1356991200;
    
    
    // Nouvelle manière le lire/ ecrire un fichier binaire avec une classe
    // Donne plus de souplesse car permet de lire et d'écrire dans n'importe quel ordre
    // Une seule valeur par ligne.
    class BinFile {
        // Le fichier binaire ouvert
        FILE* _file;
        // Vrai si le dernier paramètre a été lu ou ecrit
        bool _endParam;
        // Etat de la dernière opération, aucune autre n'est fair en cas d'erreur
        Error _error;
        // Teste la fin de la lecture
        void testEndParam();
    public:
        // Creation d'un objet de lecture/ecriture avec le fichier binaire ouvert
        BinFile(FILE* file) : _file(file), _endParam(false), _error(eNoError) {};
        
        /// Gestion des entêtes : écriture
        Error writeHeader(const char* type, ///< Le nom du type de fichier binaire IOTA
                          size_t size       ///< Taille en binaire du contenu,
        ///< ou nombre de parties dans un fichier composé
        );
        
        /// Gestion des entêtes : lecture
        Error readHeader(std::string& type, ///< Nom du type de fichier
                         time_t &time, ///< Date (non utilisé actuellement)
                         size_t &size  ///< Taille binaire ou du nombre de sous fichiers
        );
        
        // Ecriture de paramètres de différents types
        
        Error writeParam(const char*);
        Error writeParam(const std::string&);
        Error writeParam(unsigned);
        
        /// Termine la liste des paramètres
        /// INDISPENSABLE pour un format correct !
        Error writeEndParam();
        
        /// Retourne le format du fichier ouvert en début de header.
        /// Ne déplace pas la position de la lecture courante.
        /// Fonctionne correctement avec stdin
        FileFormat getFileFormat();
        
        // Lecture des paramètres
        // Attention : il faut connaitre le type de la valeur lue sinon
        // cela peut provoquer une erreur et arrete le lecture.
        
        Error readParam(std::string&);
        Error readParam(unsigned&);
        
        /// Est vrai si on a atteint la fin des paramètres
        /// Est vrai dès que le dernier paramètre a été lu, ou
        /// s'il n'y a aucun paramètre.
        bool endOfParam();
        
        /// Saute tous les paramètres restant
        /// Le fichier est alots pres à lire les données binaires
        /// ou le sous fichier.
        Error skipParam();
        
        // Etat de la lecture / ecriture
        Error error() {return _error;}
        
        // Destructeur : test si on a bien tout lu ou écrit
        // Impossible : on realise des lectures partielles
       // ~BinFile() {assert(_endParam);}
        
    };
    
    
    //////////////////////////////////////////////////////////////////////////
    // Implantation
    //////////////////////////////////////////////////////////////////////////
    
    
    FileFormat BinFile::getFileFormat() {
        int c = getc (_file);
        FileFormat format;
        switch (c) {
            case 'I' :
                format = fIOTA;
                break;
            case '<' :
                format = fXML;
                break;
            case 'K' :
                format = fKOEN;
                break;
            case -1 :
                if (feof(_file)) format = fEMPTY;
                else format = fERROR;
                break;
            default:
                format = fOTHER;
                break;
        }
        ungetc(c,_file);
        return format;
    }
    
    
    Error BinFile::writeHeader(const char* type,size_t size) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        // Ecriture de l'entête
        if (fprintf(_file,"%s\n",FID) != (sizeFID+1)) {
            return _error = eFileHeader|eWrite;
        }
        // Ecriture du type de fichier
        int s=strlen(type)+1;
        if (fprintf(_file,"%s\n",type) != s) {
            return _error = eFileHeader|eWrite|eId;
        }
/*
#ifdef __APPLE__
#include "TargetConditionals.h"
#if TARGET_OS_IPHONE
        if (fprintf(_file,"%s\n","2013_r222") == -1) {
            return _error = eFileHeader|eWrite;
        }
#else
        if (fprintf(_file,"%s\n",IOTA::key()) == -1) {
            return _error = eFileHeader|eWrite;
        }
#endif
#elif __ANDROID__
        if (fprintf(_file,"%s\n","2013_r222") == -1) {
            return _error = eFileHeader|eWrite;
        }
#else
        if (fprintf(_file,"%s\n",IOTA::key()) == -1) {
            return _error = eFileHeader|eWrite;
        }
#endif
*/
        // Ecriture du temps
        /*tm start;
         start.tm_sec=0;
         start.tm_min = 0;
         start.tm_hour = 0;
         start.tm_mon = 0;
         start.tm_mday = 1;
         start.tm_year = 113;
         time_t t0 = mktime(&start);*/
        
        //time_t t = time(NULL);
        //if (fprintf(f,"%lu\n",t-t0) == -1) {
        //    return eFileHeader|eWriteSize;
        //}
        
        // TEMPORAIRE : NE CHANGE PLUS LA DATE !!!
        if (fprintf(_file,"%lu\n",t0) == -1) {
            return _error = eFileHeader|eWriteSize;
        }
        // Ecriture de la taille en binaire
        if (fprintf(_file,"%lu\n",size) == -1) {
            return _error = eFileHeader|eWriteSize;
        }
        return eNoError;
    }
    
    /// Gestion des entêtes : lecture
    Error BinFile::readHeader(std::string& type, ///< Nom du type de fichier
                              time_t &time, ///< Date (non utilisé actuellement)
                              size_t &size  ///< Taille binaire ou du nombre de sous fichiers
    ) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        const size_t LINESIZE = 256;
        // Buffer sur la pile
        char linebuffer[LINESIZE];
        // Verifie qu'on n'est pas à la fin du fichier
        if (feof(_file)) {return eFileHeader|eRead|eEnd; }
        // Lecture de l'entête
        if (fgets(linebuffer,LINESIZE,_file) == NULL) {
            // ATTENTION : cette erreur survient si le
            // fichier a été ouvert puis jamais fermé
            return _error = eFileHeader|eRead|eVal01;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
        // Verification de la valeur de l'identifiant
        if (strcmp(linebuffer,FID) != 0) {
            return _error = eFileHeader|eRead|eValue|eVal02;
        }
        // Lecture du type de fichier
        if (fgets(linebuffer,LINESIZE, _file) == NULL) {
            return _error = eFileHeader|eRead|eVal03;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
        type = string(linebuffer);
        // Lecture de la key
        if (fgets(linebuffer,LINESIZE, _file) == NULL) {
            return _error = eFileHeader|eRead|eVal04;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
        
/*if (strcmp(linebuffer,IOTA::key()) != 0) {
#ifdef KEY
            INFO<<"**************************************";
            INFO<<"* IOTA error: file key inconsistency *";
            INFO<<"**************************************";
            exit(1);
#else
            INFO<<"****************************************";
            INFO<<"* IOTA warning: file key inconsistency *";
            INFO<<"****************************************";
#endif
            return eFileHeader|eRead|eKey;
        }
*/
        // Lecture de la date
        time_t t;
        if (fscanf(_file,"%lu\n",&t)!=1) {
            return _error = eFileHeader|eRead|eVal05;
        }
        time = t + t0;
        // Lecture de la taille
        if (fscanf(_file,"%lu\n",&size)!=1) {
            return _error = eFileHeader|eReadSize|eVal06;
        }
        return eNoError;
    }
    
    
    Error BinFile::writeEndParam() {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Ecriture de endianness
        if (fwrite(&endianness,sizeof(endianness),1,_file) != 1) {
            return _error = eFileHeader|eWrite;
        }
        // Note qu'on a bien ecrit la fin des paramètres
        _endParam = true;
        return eNoError;
    }
    
    
    void BinFile::testEndParam() {
        // Rien à faire si déjà à la fin ou si une erreur
        if (_endParam || _error != eNoError) {
            return;
        }
        // Regarde si le prochain caractère est un caractère de fin
        int c = getc(_file);
        if (c == -1) {
            // Erreur fin de fichier
            _error = eFileHeader|eRead|ePartial;
            return;
        }
        // Replace le caractère lu
        ungetc(c,_file);
        // Regarde si on a atteint un des deux caractères de fin : DC2/DC4
        // Dans l'importe quel ordre
        if (c == 0x12 || c == 0x14) {
            // Ok c'est la fin
            _endParam = true;
            // Lecture de endianness pour vérifier l'ordre
            U16 e=0;
            if (fread(&e,sizeof(e),1,_file) != 1) {
                _error =  eFileHeader|eRead|eVal07;
                return;
            }
            // Verification de endianess
            if (e != endianness) {
                _error = eFileHeader|eRead|eEndianness|eVal08;
            }
        }
    }
    
    bool BinFile::endOfParam() {
        // Test la fin
        testEndParam();
        return _endParam;
    }
    
    Error BinFile::readParam(std::string& str) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Lecture d'une chaine
        
        // Buffer sur la pile
        const size_t LINESIZE = 256;
        char linebuffer[LINESIZE];
        
        // Lecture d'une chaine de caractère
        if (fgets(linebuffer,LINESIZE,_file) == NULL) {
            return _error = eFileHeader|eRead;
        }
        // Supression du caractère de fin
        chomp(linebuffer);
        str = std::string(linebuffer);
        
        // regarde si c'est le dernier paramètre
        testEndParam();
        return eNoError;
    }
    
    
    Error BinFile::readParam(unsigned& u) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Lecture du paramètre
        if (fscanf(_file,"%u\n",&u) != 1) {
            return _error = eFileHeader|eRead|eValue|eVal07;
        }
        // regarde si c'est le dernier paramètre
        testEndParam();
        return eNoError;
    }
    
    
    Error BinFile::skipParam() {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Rien à faire si déjà à la fin
        if (_endParam) {
            return _error;
        }
        // Ce n'est pas la fin : lecture jusqu'a lire le endianess
        int c = 0;
        while ((c != EOF) && (c != 0x12) && (c != 0x14)) {
            c = getc(_file);
        }
        // Si on n'a pas vu les codes de endianess
        if (c == EOF) {
            // C'est une erreur
            _endParam = true;
            return _error = eFileRead|eFileHeader|ePartial|eVal09;
        }
        // Replace le caractère lu
        ungetc(c,_file);
        // Lance le test de fin de param qui doit être vrai
        testEndParam();
        assert(_endParam == true);
        // On doit avoir mangé les caractères endianess dans le bon ordre
        return _error;
    }
    
    
    Error BinFile::writeParam(const char* str) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Ecriture de la chaine
        int s=strlen(str)+1;
        if (fprintf(_file,"%s\n",str) != s) {
            return _error = eFileHeader|eWrite|eType;
        }
        return eNoError;
    }
    
    inline
    Error BinFile::writeParam(const std::string& str) {
        return writeParam(str.c_str());
    }
    
    Error BinFile::writeParam(unsigned p) {
        // Se fait plus rien si une erreur
        if (_error != eNoError) return _error;
        
        // Ecriture du paramètre
        if (fprintf(_file,"%u\n",p) == -1) {
            return _error = eFileHeader|eWrite|eVal06;
        }
        return eNoError;
    }
    
    
    
    //////////////////////////////////////////////////////////////////////////
    // ANCIENNE PRECEDURES DE LECTURE / ECRITURE
    // POUR COMPATIBILITE AVEC LE CODE
    // NE PLUS UTILISER
    //////////////////////////////////////////////////////////////////////////
    
    
    ///\brief Retourne le format du fichier ouvert en début de header.
    /// Ne déplace pas la position de la lecture courante.
    /// Fonctionne correctement avec stdin
    FileFormat getFileFormat(FILE* f);
    
    /// Gestion des entêtes : écriture
    Error writeHeader(FILE* f,          ///< Un fichier ouvert en ecriture
                      const char* type, ///< Le nom du type de fichier binaire IOTA
                      size_t size       ///< Taille en binaire du contenu,
    ///< ou nombre de parties dans un fichier composé
    );
    /// Gestion des entêtes : lecture
    Error readHeader(FILE* f,      ///< Un fichier ouvert en lecture
                     string& type, ///< Récuperation du nom du type der fichier
                     time_t &time, ///< Récuperation de la date (non utilisé actuellement)
                     size_t &size  ///< Récuperation de la taille binaire ou du nombre de sous fichiers
    );
    
    
    // Attention : un seul appel possible par fichier, car
    // les caractères endian et de test de debut de zone data sont
    // produit à ce momment  (A CHANGER !!!)
    // ATTENTION : il faut obligatoirement utiliser une de ces fonctions
    // pour un format correct.
    
    
    Error writeParam(FILE* f,unsigned);
    Error readParam(FILE* f,unsigned&);
    
    Error writeParam(FILE* f,unsigned,unsigned);
    Error readParam(FILE* f,unsigned&,unsigned&);
    
    ///\todo Changer les write/read car il faut implanter toutes le combinaisons => penible !!!
    /// Voir une version générique pour 1,2,3,... n paramètres
    
    Error writeParam(FILE* f,string,unsigned,unsigned);
    Error readParam(FILE* f,string&,unsigned&,unsigned&);
    
    // pour les messages
    Error writeParam(FILE* f,string&,string&);
    Error readParam(FILE* f,string&,string&);
    
    // pour les images format RAW
    Error writeParam(FILE* f,const char*,size_t,unsigned,unsigned);
    Error readParam(FILE* f,string&,size_t&,unsigned&,unsigned&);
    
    // Pour la classe FMatrix
    Error writeParam(FILE* f,const char*,size_t,U64,U32);
    Error readParam(FILE* f,string&,size_t&,U64&,U32&);
    
    // Saute les paramètres
    Error skipParam(FILE* f);
    
    /// Pas de paramètres !!!
    /// Ecrit simplement le code de fin des paramètres
    Error writeEndParam(FILE* f);
    
    //Codebook Header
    // JPC RIEN NE DOIT ETRE SPECIFIQUE ICI : a enlever
    Error writeCodebookHeader(FILE* file, eCodebookType codebookType, U32 nbCluster);
    Error readCodebookHeader(FILE* file, eCodebookType &codebookType, U32 &nbCluster);
    
    
    
    //////////////////////////////////////////////
    
    
    inline
    FileFormat getFileFormat(FILE* f) {
        int c = getc (f);
        FileFormat format;
        switch (c) {
            case 'I' :
                format = fIOTA;
                break;
            case '<' :
                format = fXML;
                break;
            case 'K' :
                format = fKOEN;
                break;
            case -1 :
                if (feof(f)) format = fEMPTY;
                else format = fERROR;
                break;
            default:
                format = fOTHER;
                break;
        }
        ungetc(c,f);
        return format;
    }
    
    
    
    inline
    Error writeHeader(FILE* f,const char* type,size_t size) {
        // Ecriture de l'entête
        if (fprintf(f,"%s\n",FID) != (sizeFID+1)) {
            return eFileHeader|eWrite;
        }
        // Ecriture du type de fichier
        int s=strlen(type)+1;
        if (fprintf(f,"%s\n",type) != s) {
            return eFileHeader|eWrite|eId;
        }
/*
#ifdef __APPLE__
#include "TargetConditionals.h"
#if TARGET_OS_IPHONE
        if (fprintf(f,"%s\n","2013_r222") == -1) {
            return eFileHeader|eWrite;
        }
#else
        if (fprintf(f,"%s\n",IOTA::key()) == -1) {
            return eFileHeader|eWrite;
        }
#endif
#elif __ANDROID__
        if (fprintf(f,"%s\n","2013_r222") == -1) {
            return eFileHeader|eWrite;
        }
#else
        if (fprintf(f,"%s\n",IOTA::key()) == -1) {
            return eFileHeader|eWrite;
        }
#endif
*/
        // Ecriture du temps
        /*tm start;
         start.tm_sec=0;
         start.tm_min = 0;
         start.tm_hour = 0;
         start.tm_mon = 0;
         start.tm_mday = 1;
         start.tm_year = 113;
         time_t t0 = mktime(&start);*/
        
        //time_t t = time(NULL);
        //if (fprintf(f,"%lu\n",t-t0) == -1) {
        //    return eFileHeader|eWriteSize;
        //}
        
        // TEMPORAIRE : NE CHANGE PLUS LA DATE !!!
        if (fprintf(f,"%lu\n",t0) == -1) {
            return eFileHeader|eWriteSize;
        }
        // Ecriture de la taille en binaire
        if (fprintf(f,"%lu\n",size) == -1) {
            return eFileHeader|eWriteSize;
        }
        return eNoError;
    }
    
    inline
    Error writeEndParam(FILE* f) {
        // Ecriture de endianness
        if (fwrite(&endianness,sizeof(endianness),1,f) != 1) {
            return eFileHeader|eWrite;
        }
        return eNoError;
    }
    
    
    
    inline
    Error readHeader(FILE* f,string& type,time_t &time,size_t &size ) {
        const size_t LINESIZE = 256;
        // Buffer sur la pile
        char linebuffer[LINESIZE];
        // Verifie qu'on n'est pas à la fin du fichier
        if (feof(f)) {return eFileHeader|eRead|eEnd; }
        // Lecture de l'entête
        if (fgets(linebuffer,LINESIZE,f) == NULL) {
            // ATTENTION : cette erreur survient si le
            // fichier a été ouvert puis jamais fermé
            return eFileHeader|eRead|eVal01;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
        // Verification de la valeur de l'identifiant
        if (strcmp(linebuffer,FID) != 0) {
            return eFileHeader|eRead|eValue|eVal02;
        }
        // Lecture du type de fichier
        if (fgets(linebuffer,LINESIZE, f) == NULL) {
            return eFileHeader|eRead|eVal03;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
        type = string(linebuffer);
        // Lecture de la key
        if (fgets(linebuffer,LINESIZE, f) == NULL) {
            return eFileHeader|eRead|eVal04;
        }
        // Supprime le caractère \n
        chomp(linebuffer);
/*
        if (strcmp(linebuffer,IOTA::key()) != 0) {
#ifdef KEY
            INFO<<"**************************************";
            INFO<<"* IOTA error: file key inconsistency *";
            INFO<<"**************************************";
            exit(1);
#else
            INFO<<"****************************************";
            INFO<<"* IOTA warning: file key inconsistency *";
            INFO<<"****************************************";
#endif
            return eFileHeader|eRead|eKey;
        }
*/
        // Lecture de la date
        time_t t;
        if (fscanf(f,"%lu\n",&t)!=1) {
            return eFileHeader|eRead|eVal05;
        }
        time = t + t0;
        // Lecture de la taille
        if (fscanf(f,"%lu\n",&size)!=1) {
            return eFileHeader|eReadSize|eVal06;
        }
        return eNoError;
    }
    
    inline
    Error readEnd(FILE* f) {
        // Lecture de endianness
        U16 e=0;
        if (fread(&e,sizeof(e),1,f) != 1) {
            return eFileHeader|eRead|eVal07;
        }
        // Verification de endianess
        if (e != endianness) {
            return eFileHeader|eRead|eEndianness|eVal08;
        }
        return eNoError;
    }
    
    
    Error writeParam(FILE* f,unsigned p) {
        // Ecriture du paramètre
        if (fprintf(f,"%u\n",p) == -1) {
            return eFileHeader|eWrite|eVal06;
        }
        return writeEndParam(f);
    }
    
    Error writeParam(FILE* f,string s,unsigned p1,unsigned p2) {
        // Ecriture du paramètre
        if (fprintf(f,"%s\n%u %u\n",s.c_str(),p1,p2) == -1) {
            return eFileHeader|eWrite|eVal06;
        }
        return writeEndParam(f);
    }
    
    Error writeParam(FILE* f,unsigned p1,unsigned p2) {
        // Ecriture du paramètre
        if (fprintf(f,"%u %u\n",p1,p2) == -1) {
            return eFileHeader|eWrite|eVal06;
        }
        return writeEndParam(f);
    }
    
    Error writeParam(FILE* f,string p1) {
        // Ecriture du paramètre
        if (fprintf(f,"%s\n",p1.c_str()) == -1) {
            return eFileHeader|eWrite|eVal06;
        }
        return writeEndParam(f);
    }
    
    Error writeParam(FILE* f,string &p1,string &p2) {
        // Ecriture du paramètre
        if (fprintf(f,"%s %s\n",p1.c_str(),p2.c_str()) == -1) {
            return eFileHeader|eWrite|eVal06;
        }
        return writeEndParam(f);
    }
    
    Error skipParam(FILE* f) {
        // Lecture j'usqu'a lire le endianess
        char c;
        while ((fread(&c,1,1,f) == 1) && (c != 0x12) && (c != 0x14));
        if ((c == 0x12) || (c == 0x14)) {
            // lit l'autre octet de l'endianess
            if ((fread(&c,1,1,f) != 1)) {
                return eFileRead | eEndianness;
            } else {
                return eNoError;
            }
        }
        return eFileRead | ePartial;
    }
    
    
    
    Error readParam(FILE* f,unsigned &p) {
        // Lecture du paramètre
        if (fscanf(f,"%u\n",&p) != 1) {
            return eFileHeader|eRead|eValue|eVal07;
        }
        return readEnd(f);
    }
    
    Error readParam(FILE* f,unsigned& p1, unsigned& p2) {
        // Lecture du paramètre
        if (fscanf(f,"%u %u\n",&p1,&p2) != 2) {
            return eFileHeader|eRead|eValue|eVal07;
        }
        return readEnd(f);
    }
    
    Error readParam(FILE* f,string& s,unsigned& p1, unsigned& p2) {
        char tmp1[80];
        // Lecture du paramètre
        if (fscanf(f,"%s\n%u %u\n",tmp1,&p1,&p2) != 3) {
            return eFileHeader|eRead|eValue|eVal07;
        }
        s = string(tmp1);
        return readEnd(f);
    }
    
    
    Error readParam(FILE* f, string& p1) {
        // Lecture du paramètre
        // 80 en dur. Attention si argument plus grand
        char tmp1[80];
        if (fscanf(f,"%s\n",tmp1) != 1) {
            return eFileHeader|eRead|eValue|eVal07;
        }
        p1 = string(tmp1);
        return readEnd(f);
    }
    
    
    Error readParam(FILE* f, string& p1, string& p2) {
        // Lecture du paramètre
        // 80 en dur. Attention sur argument plus grand
        char tmp1[80];
        char tmp2[80];
        if (fscanf(f,"%s %s\n",tmp1, tmp2) != 2) {
            return eFileHeader|eRead|eValue|eVal07;
        }
        p1 = string(tmp1);
        p2 = string(tmp2);
        return readEnd(f);
    }
    
    Error writeParam(FILE* f,const char* nameT,size_t sizeT,U64 nbVect,U32 vectDim) {
        
        // Ecriture du type T
        int s=strlen(nameT)+1;
        if (fprintf(f,"%s\n",nameT) != s) {
            return eFileHeader|eWrite|eType;
        }
        // Ecriture des paramètres
        if (fprintf(f,"%lu %lu %u\n",sizeT,(long unsigned)(nbVect),unsigned(vectDim)) == -1) {
            return eFileHeader|eWrite|eValue;
        }
        return writeEndParam(f);
    }
    
    Error readParam(FILE* f,string& nameT,size_t& sizeT,U64& nbVect,U32& vectDim) {
        
        // Buffer sur la pile
        const size_t LINESIZE = 256;
        char linebuffer[LINESIZE];
        
        // Lecture du nom du type T
        if (fgets(linebuffer,LINESIZE,f) == NULL) {
            return eFileHeader|eRead;
        }
        chomp(linebuffer);
        nameT = string(linebuffer);
        
        // Lecture des autres paramètres
        long unsigned lu;
        unsigned u;
        if (fscanf(f,"%lu %lu %u\n",&sizeT,&lu,&u) != 3) {
            return eFileHeader|eRead|eValue|eVal08;
        }
        nbVect = lu;
        vectDim = u;
        return readEnd(f);
    }
    
    Error writeParam(FILE* f,const char* nameT,size_t sizeT,unsigned x,unsigned y) {
        
        // Ecriture du type T
        int s=strlen(nameT)+1;
        if (fprintf(f,"%s\n",nameT) != s) {
            return eFileHeader|eWrite|eType;
        }
        // Ecriture des paramètres
        if (fprintf(f,"%lu %u %u\n",sizeT,x,y) == -1) {
            return eFileHeader|eWrite|eValue;
        }
        return writeEndParam(f);
    }
    
    
    Error readParam(FILE* f,string& nameT,size_t& sizeT,unsigned& x,unsigned& y) {
        
        // Buffer sur la pile
        const size_t LINESIZE = 256;
        char linebuffer[LINESIZE];
        
        // Lecture du nom du type T
        if (fgets(linebuffer,LINESIZE,f) == NULL) {
            return eFileHeader|eRead;
        }
        chomp(linebuffer);
        nameT = string(linebuffer);
        
        // Lecture des autres paramètres
        if (fscanf(f,"%lu %u %u\n",&sizeT,&x,&y) != 3) {
            return eFileHeader|eRead|eValue|eVal08;
        }
        return readEnd(f);
    }
    
    // write the header of the codebook based on the given type, the function will choose the header beaed on the type and will write the given number of clusters
    // it is done like this as a way to unify header writing for codebooks
    Error writeCodebookHeader(FILE* file, eCodebookType codebookType, size_t size, U32 nbCluster) {
        Error e=eNoError;
        // write header based on given type
        switch (codebookType) {
            case cOriginal:
                e = writeHeader(file,headerOriginal,size);
                break;
            case cHierarchical:
                e = writeHeader(file,headerHierarchical,size);
                break;
            default:
                e = eNotExist;
        }
        if (e == eNoError){
            e = writeParam(file, nbCluster);
        }
        return e;
        
    }
    
    // read the header of the codebook and give its type, and the number of clusters
    // it is done like this as a way to unify header reading for codebooks
    Error readCodebookHeader(FILE* file, eCodebookType &codebookType, size_t &size, U32 &nbCluster) {
        Error e;
        string type;
        time_t time;
        
        //read the header
        e = readHeader(file,type,time,size);
        if (e != eNoError) return e;
        
        readParam(file, nbCluster);
        // get and verify the type
        if (type == headerOriginal) {
            codebookType = cOriginal;
        } else if (type == headerHierarchical) {
            codebookType = cHierarchical;
        } else {
            return eFileHeader|eType;
        }
        return e;
    }
    
    
}

#endif

