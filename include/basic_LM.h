#ifndef basic_LM_h
#define basic_LM_h


#include "frequency.h"
#include "tool.h"
#include <cstring>
#include <vector>
#include <unordered_map>
#include <algorithm>



//Return the probability that the query was generated by the model of the document using only term frequency in the document (no smoothing)
double basic_language_model(const std::vector<std::string> &query , const std::vector<std::string> &document){

	size_t doc_length = document.size();

	if(doc_length == 0){return 0;}

	double proba = 0;

	std::vector<std::string> check;

	for(unsigned int i = 0 ; i < query.size() ; i++){

		if( find(check.begin() , check.end() , query[i]) == check.end() ){
			proba += log( 1 + (double)term_freq(document , query[i])/doc_length );
			check.push_back(query[i]);

		}

	}

	return proba;

}

//Return a list of the probability that the query was generated by the model of each of the documents using only term frequency in the document (no smoothing)
std::unordered_map <int,double> basic_language_model(const std::vector<std::string> &query , const std::unordered_map < int , std::vector<std::string> > &collection){

	std::unordered_map <int,double> list_doc;

	double proba;

	auto iterator = collection.begin();

	while(iterator != collection.end() ){

		proba = basic_language_model(query , iterator->second);
		if(proba > 0){list_doc[iterator->first]=proba;}

		iterator++;

	}

	return list_doc;

}


//Same as before but with all the queries and sort documents by their score
std::vector< std::vector< std::pair<int,double> > > basic_language_model(const std::unordered_map <int , std::vector<std::string> > &queries , const std::unordered_map < int , std::vector<std::string> > &collection , const int k){

	std::vector< std::vector< std::pair<int,double> > > list_docs(queries.size());

	auto iterator = queries.begin();

	while( iterator != queries.end() ){

		//std::cout<<"\rProcessing query "<<i+1<<"/"<<queries.size()<<std::flush;

		list_docs[iterator->first] = kfirst_docs( basic_language_model(iterator->second , collection) , k);

		iterator++;

	}

	return list_docs;

}



#endif
